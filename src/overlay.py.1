"""
Overlay window for displaying visual alerts
Оверлейное окно для отображения визуальных оповещений
"""

# Standard library imports
from threading import Thread, Event, Timer
import time

# Third-party imports
import win32gui
import win32con
import win32api

class WindowState:
    """State of the overlay window"""
    def __init__(self):
        self.should_show = False
        self.is_running = True
        self.is_visible = False  # Флаг текущего состояния видимости
        self.hide_timer = None  # Timer for hide delay
        self.HIDE_DELAY = 0.25  # Hide delay in seconds

class WindowHandles:
    """Window handles and resources"""
    def __init__(self):
        self.wc = None
        self.hwnd = None
        self.brush = None

class WindowAppearance:
    """Window appearance settings"""
    def __init__(self):
        self.window_opacity = 64  # Default window opacity
        self.window_color = (255, 0, 0)  # Default color (red)

class OverlayWindow:
    """Overlay window for displaying visual alerts"""
    def __init__(self):
        """Initialize the overlay window"""
        self.state = WindowState()
        self.handles = WindowHandles()
        self.appearance = WindowAppearance()
        self.close_event = Event()

        # Start window thread
        self.thread = Thread(target=self._run_window, daemon=True)
        self.thread.start()
        time.sleep(0.1)  # Wait for window creation

    def _register_window_class(self):
        """Register the overlay window class"""
        # Get module handle
        # pylint: disable=c-extension-no-member
        try:
            hinst = win32api.GetModuleHandle(None)
            if not hinst:
                print("Failed to get module handle")
                return

            # Register window class
            # pylint: disable=c-extension-no-member
            wc = win32gui.WNDCLASS()
            wc.hInstance = hinst
            wc.lpfnWndProc = self._window_proc
            wc.lpszClassName = "GazeTrackerOverlay"
            wc.style = win32con.CS_HREDRAW | win32con.CS_VREDRAW

            atom = win32gui.RegisterClass(wc)
            if atom:
                self.handles.wc = wc

        except win32gui.error as e:
            # Error code 1410: CLASS_ALREADY_EXISTS
            if e.winerror == 1410:
                # Class already registered, which is fine
                pass
            else:
                # Re-raise unexpected win32gui errors
                raise

        except win32api.error as e:
            # Handle GetModuleHandle errors
            print(f"Failed to get module handle: {e}")

    def _create_overlay_window(self):
        """Create a transparent overlay window"""
        if not self.handles.wc:
            self._register_window_class()

        # Get screen dimensions
        screen_width = win32api.GetSystemMetrics(win32con.SM_CXSCREEN)
        screen_height = win32api.GetSystemMetrics(win32con.SM_CYSCREEN)

        # Extended window styles for transparency and click-through
        ex_style = (
            win32con.WS_EX_LAYERED |      # For transparency
            win32con.WS_EX_TRANSPARENT |   # Click-through
            win32con.WS_EX_TOPMOST |       # Always on top
            win32con.WS_EX_NOACTIVATE     # Don't activate/focus
        )

        # Create window
        # pylint: disable=c-extension-no-member
        self.handles.hwnd = win32gui.CreateWindowEx(
            ex_style,
            self.handles.wc.lpszClassName,
            None,
            win32con.WS_POPUP,
            0, 0, screen_width, screen_height,
            None,
            None,
            self.handles.wc.hInstance,
            None
        )

        if not self.handles.hwnd:
            print("Failed to create window")
            return

        # Create brush for background
        self._create_brush()

        # Set window properties
        # pylint: disable=c-extension-no-member
        win32gui.SetLayeredWindowAttributes(
            self.handles.hwnd,
            win32api.RGB(*self.appearance.window_color),
            self.appearance.window_opacity,
            win32con.LWA_COLORKEY | win32con.LWA_ALPHA
        )

        # Set window position and make it topmost
        win32gui.SetWindowPos(
            self.handles.hwnd,
            win32con.HWND_TOPMOST,
            0, 0, screen_width, screen_height,
            win32con.SWP_NOACTIVATE | win32con.SWP_SHOWWINDOW
        )

    def _create_brush(self):
        """Create brush for window background"""
        # pylint: disable=c-extension-no-member
        self.handles.brush = win32gui.CreateSolidBrush(
            win32api.RGB(*self.appearance.window_color)
        )

    def _window_proc(self, hwnd, msg, wparam, lparam):
        """Window procedure for handling window messages"""
        # pylint: disable=c-extension-no-member
        if msg == win32con.WM_PAINT:
            if self.state.should_show:
                hdc, ps = win32gui.BeginPaint(hwnd)
                rect = win32gui.GetClientRect(hwnd)

                # Create memory DC and bitmap
                memdc = win32gui.CreateCompatibleDC(hdc)
                bitmap = win32gui.CreateCompatibleBitmap(hdc, rect[2], rect[3])
                old_bitmap = win32gui.SelectObject(memdc, bitmap)

                # Create and fill background with brush
                if not self.handles.brush:
                    self._create_brush()
                win32gui.FillRect(memdc, rect, self.handles.brush)

                # Copy to window
                win32gui.BitBlt(
                    hdc,
                    0, 0, rect[2], rect[3],
                    memdc,
                    0, 0,
                    win32con.SRCCOPY
                )

                # Cleanup
                win32gui.SelectObject(memdc, old_bitmap)
                win32gui.DeleteObject(bitmap)
                win32gui.DeleteDC(memdc)
                win32gui.EndPaint(hwnd, ps)

        return win32gui.DefWindowProc(hwnd, msg, wparam, lparam)

    def _delayed_hide(self):
        """Callback для отложенного скрытия окна"""
        self.state.should_show = False

    def _run_window(self):
        """Run the overlay window"""
        self._create_overlay_window()

        while self.state.is_running and not self.close_event.is_set():
            # pylint: disable=c-extension-no-member
            if win32gui.PumpWaitingMessages() == -1:  # WM_QUIT received
                break

            if self.state.should_show != self.state.is_visible:
                self.update()

            time.sleep(0.016)  # ~60 FPS

        # Cleanup window in the same thread where it was created
        if self.handles.hwnd:
            try:
                # pylint: disable=c-extension-no-member
                win32gui.DestroyWindow(self.handles.hwnd)
                self.handles.hwnd = None

            except win32gui.error as e:
                # Error codes:
                # ERROR_INVALID_WINDOW_HANDLE (1400): Invalid window handle
                # ERROR_INVALID_HANDLE (6): The handle is invalid
                # ERROR_ACCESS_DENIED (5): Access is denied
                if e.winerror in (1400, 6, 5):
                    self.handles.hwnd = None  # Window already destroyed or can't be accessed
                else:
                    # Re-raise unexpected win32gui errors
                    raise

    def show(self, show=True):
        """Show or hide the overlay"""
        if show:
            # Если показываем окно, отменяем любой отложенный таймер скрытия
            if self.state.hide_timer:
                self.state.hide_timer.cancel()
                self.state.hide_timer = None
            self.state.should_show = True
            if not self.state.is_visible and self.handles.hwnd:
                # pylint: disable=c-extension-no-member
                win32gui.ShowWindow(self.handles.hwnd, win32con.SW_SHOWNA)
                win32gui.InvalidateRect(self.handles.hwnd, None, True)
                win32gui.UpdateWindow(self.handles.hwnd)
                self.state.is_visible = True
        else:
            # Запускаем таймер для скрытия окна с задержкой
            if not self.state.hide_timer:
                self.state.hide_timer = Timer(self.state.HIDE_DELAY, self._delayed_hide)
                self.state.hide_timer.start()

    def update(self):
        """Update overlay window"""
        if not self.handles.hwnd:
            return

        # Get screen dimensions
        # pylint: disable=c-extension-no-member
        screen_width = win32api.GetSystemMetrics(win32con.SM_CXSCREEN)
        screen_height = win32api.GetSystemMetrics(win32con.SM_CYSCREEN)

        # Show or hide window
        if self.state.should_show and not self.state.is_visible:
            # pylint: disable=c-extension-no-member
            win32gui.ShowWindow(self.handles.hwnd, win32con.SW_SHOWNA)
            win32gui.SetWindowPos(
                self.handles.hwnd,
                win32con.HWND_TOPMOST,
                0, 0, screen_width, screen_height,
                win32con.SWP_NOACTIVATE | win32con.SWP_SHOWWINDOW
            )
            win32gui.InvalidateRect(self.handles.hwnd, None, True)
            win32gui.UpdateWindow(self.handles.hwnd)
            self.state.is_visible = True
        elif not self.state.should_show and self.state.is_visible:
            win32gui.ShowWindow(self.handles.hwnd, win32con.SW_HIDE)
            self.state.is_visible = False

    def get_color_hex(self):
        """Get overlay window color as hex string"""
        return '#{:02x}{:02x}{:02x}'.format(*self.appearance.window_color)

    def set_color(self, r, g, b):
        """Set overlay window color"""
        self.appearance.window_color = (r, g, b)
        if self.handles.brush:
            # pylint: disable=c-extension-no-member
            win32gui.DeleteObject(self.handles.brush)
            self._create_brush()

    def set_color_hex(self, hex_color):
        """Set overlay window color from hex string"""
        # Convert hex to RGB
        hex_color = hex_color.lstrip('#')
        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)
        self.set_color(r, g, b)

    def set_opacity(self, opacity):
        """Set overlay window opacity (0-255)"""
        self.appearance.window_opacity = opacity
        if self.handles.hwnd:
            # pylint: disable=c-extension-no-member
            win32gui.SetLayeredWindowAttributes(
                self.handles.hwnd,
                win32api.RGB(*self.appearance.window_color),
                opacity,
                win32con.LWA_COLORKEY | win32con.LWA_ALPHA
            )

    def close(self):
        """Close the overlay window"""
        if self.state.is_running:
            self.state.is_running = False
            self.close_event.set()

            # Cleanup resources
            if self.handles.brush:
                # pylint: disable=c-extension-no-member
                win32gui.DeleteObject(self.handles.brush)
                self.handles.brush = None

            # Ждем завершения потока окна
            if self.thread.is_alive():
                self.thread.join(timeout=1.0)
